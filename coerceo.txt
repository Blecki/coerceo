

COERCEO

Binary Table
0000 	0
0001 	1
0010 	2
0011 	3
0100 	4
0101 	5
0110 	6
0111 	7
1000 	8
1001 	9
1010 	A
1011 	B
1100 	C
1101 	D
1110 	E
1111 	F

A tile
   __
 /\B /\
/W \/W \
--------
\B /\B /
 \/W \/
   --

Encoding a tile in 1 byte: [00] [000000]
 Status code (A) ------------+     |
  Triangle bit mask (B) -----------+

A: Tile status codes
00: Ordinary tile
01: Tile held by W
10: Tile held by B
11: Tile out of play

B: One bit per triangle in tile. Since pieces can only move on triangles of their own color, a single bit is enough. 
	Bits are actually stored in reverse order.

/// Make this immutable: Instead of set, add mutator functions that return a new copy.
struct Tile
{
	byte ID;
	byte Data;

	public byte Status { 
		get { return (Data & 0xC0) >> 6; } 
		set { Data = (Data & 0x3F) | ((value & 0x03) << 6); }
	}

	public byte GetTriangle(byte Index) { ... }

	public Tile WithStatus(byte NewStatus) { ... }

	public Tile WithTriangle(byte Index, byte NewValue) { ... }

	public bool IsHeldBy(byte Player) { ... }
}

The starting board - 19 tiles
        __               __
     __/00\__         __/00\__    Neighbor 
  __/01\__/02\__     /01\__/05\    Directions   
 /03\__/04\__/05\    \__/  \__/       
 \__/06\__/07\__/    /02\__/04\       
 /08\__/09\__/0A\    \__/03\__/      
 \__/0B\__/0C\__/       \__/  
 /0D\__/0E\__/0F\          
 \__/10\__/11\__/          
    \__/12\__/            
       \__/

Initial Piece Placements (tile, triangle):

0: 1 5
1: 2 5
2: 1 4
3: 0 2
4: 1 5
5: 0 4
6: 0 2
7: 0 4
8: 0 3
9: 
A: 0 3
B: 1 3
C: 3 5
D: 1 3
E: 2 4
F: 3 5
10: 1 4
11: 2 5
12: 2 4



Game State Tree Sort Order - By sorting on the tiles most likely to survive late into the game first, we subdivide the tree of game states more evenly.

09 04 06 0B 0E 0C 07 08 10 11 0A 02 01 00 03 0D 12 0F 05

Adjacency table: Tile to Tile adjacency (This list should be ordered.) FF indicates a gap in the list. The north neighbor is always listed first. Listing proceeds counter clockwise.

-- Adjacency Table --
00: FF FF 01 04 02 FF
01: FF FF 03 06 04 00
02: FF 00 04 07 05 FF
03: FF FF FF 08 06 01 
04: 00 01 06 09 07 02
05: FF 02 07 0A FF FF 
06: 01 03 08 0B 09 04
07: 02 04 09 0C 0A 05
08: 03 FF FF 0D 0B 06
09: 04 06 0B 0E 0C 07
0A: 05 07 0C 0F FF FF
0B: 06 08 0D 10 0E 09
0C: 07 09 0E 11 0F 0A
0D: 08 FF FF FF 10 0B
0E: 09 0B 10 12 11 0C
0F: 0A 0C 11 FF FF FF
10: 0B 0D FF FF 12 0E
11: 0C 0E 12 FF FF 0F
12: 0E 10 FF FF FF 11

Encoding the entire game board: [STATE HEADER] [TILE X 19]
State Header:    [0] [0000000]
 Whos turn next --+    |
  Reserved ------------+

struct StateHeader
{
	byte Data;

	public byte WhoseTurnNext { get { return (Data & 0x80) >> 7; } }
}

struct Board 
{
	fixed byte[20] Data;

	public StateHeader Header { get { return new StateHeader(Data[0]); } }

	public IEnumerable<Tile> Tiles { get { for (var i = 1; i < 20; ++i) yield return new Tile(i - 1, Data[i]); } }
	public IEnumerable<Triangle> Triangles { get { ... } }

	public Tile GetTile(byte Index) { return new Tile(Data[Index + 1]); }
	public byte GetTriangle(TriangleCoordinate Coordinate) { return GetTile(Coordinate.Tile).GetTriangle(Coordinate.Triangle); }

	public Board WithTile(byte Index, Tile Tile) { ... }
}

Triangle adjacency
	Each triangle has up to 6 adjacent triangles. This table could potentionally be generated.

   __
 /\B0/\
/W1\/W5\
--------
\B2/\B4/
 \/W3\/
   --

Movement Adjacency:

B0: 0:B2 1:B4 F:B2 F:B4 5:B2 0:B4
W1: 1:W5 1:W3 2:W5 F:W3 F:W5 0:W3
B2: 1:B4 2:B0 2:B4 3:B0 F:B4 F:B0
W3: F:W1 2:W5 3:W1 3:W5 4:W1 F:W5
B4: F:B0 F:B2 3:B0 4:B2 4:B0 5:B2
W5: 0:W3 F:W1 F:W3 4:W1 5:W3 5:W1

Surround Adjacency:

B0: 0:W3 F:W1 F:W5
W1: 1:B4 F:B2 F:B0
B2: 2:W5 F:W3 F:W1
W3: 3:B0 F:B4 F:B2
B4: 4:W1 F:W5 F:W3
W5: 5:B2 F:B0 F:B4

Exposed Adjacency: What triangle is the neighboring tile is potentially surrounded when this tile is removed.
+-- Relative direction
|    +-- Exposed triangle
0 	W3
1   B4
2   W5
3   B0
4   W1
5   B2

Encoding a triangle: TILE:TRIANGLE, as in 0D:W1, the W1 triangle on the 0D tile.

Encoding a move: [00000][000] [000][00][000] [00000000] [00000000]
 Tile -------------+      |     |   |    |     |          |
  Triangle ---------------+     |   |    |     +----------+
    Direction-------------------+   |    |     |
     Movement type -----------------+    |     |
      Reserved --------------------------+     |
       Move Score -----------------------------+

Movement type
00: Move piece
01: Trade in tiles to snipe piece
10: Resign

struct TriangleCoordinate
{
	byte Data;

	public byte Tile { get { return (Data & 0xF8) >> 3; } }
	public byte Triangle { get { return (Data & 0x07); } }
}

struct Move
{
	fixed byte[4] Data;

	public TriangleCoordinate Coordinate { get { return new TriangleCoordinate(Data[0]); } }
	public byte Tile { get { return (new TriangleCoordinate(Data[0])).Tile; } }
	public byte Triangle { get { return (new TriangleCoordinate(Data[0])).Triangle; } }

	public byte Direction { get { ... } }
	public byte Type { get { ... } }
}

Coordinate FindMoveNeighbor(Coordinate Of, byte Direction)
{
	var relativeMove = MoveAdjacency[Of.Triangle][Direction];
	if (relativeMove.Direction == 0x0F)
		return new TriangleCoordinate(Of.Tile, relativeMove.Triangle)
	else 
		return new TriangleCoordinate( TileAdjacency[Of.Tile][ relativeMove.Direction ], relativeMove.Triangle);
}

Coordinate FindSurroundNeighbor(Coordinate Of, byte Direction)
{
	var relativeMove = SurroundAdjacency[Of.Triangle][Direction];
	if (relativeMove.Direction == 0x0F)
		return new TriangleCoordinate(Of.Tile, relativeMove.Triangle);
	else
		return new TriangleCoordinate( TileAdjacency[Of.Tile][relativeMove.Direction], relativeMove.Triangle);
}

Board ApplyMove(Board Board, Move Move)

	var checkForSurrounded = new List<TriangleCoordinate>();
	var checkForEmpty = new List<byte>();

	switch (Move.Type)
	{
		
		case Resign: 
	 		End game in loss for Board.WhoseTurn

	 	case Trade in tiles to snipe piece:
	 		{
	 			// Verify move is legal.

	 			// Reject move if attempting to snipe own piece.
	 			if (Move.Triangle % 2 == Board.WhoseTurn) return Rejected;

	 			// Reject move if player does not hold at least two tiles.
	 			var heldTileCount = Board.Tiles.Count(t => t.IsHeldBy(Board.WhoseTurnNext));
	 			if (heldTileCount < 2) return Rejected;

	 			// Reject move if there is no enemy piece at the location.
	 			if (Board.GetTriangle(Move.Coordinate) == 0) return Rejected;

	 			// Turn is legal, mutate board.
	 			foreach (var tile in Board.Tiles.Where(t => t.IsHeldBy(Board.WhoseTurnNext).Take(2)))
	 				Board = Board.WithTile(tile.ID, tile.WithStatus(OutOfPlay));
	 			Board = Board.WithTile(Move.Tile, Board.GetTile(Move.Tile).WithTriangle(Move.Triangle, 0));

	 			checkForEmpty.Add(Move.Tile);
	 		}

	 	case Move piece
	 		{
	 			// Verify move is legal.

	 			// Reject move if attempting to move opponent piece.
	 			if (Move.Triangle % 2 != Board.WhoseTurn) return Rejected;

	 			// Reject move if there is no piece at the location.
	 			if (Board.GetTriangle(Move.Coordinate) == 0) return Rejected;

	 			// Find destination triangle coordinate.
	 			var dest = FindMoveNeighbor(Move.Coordinate, Move.Direction);

	 			// Reject move if player attempted to move off board.
	 			if (dest.Tile = 0xFF) return Rejected;
	 			if (Board.GetTile(dest.Tile).IsOutOfPlay()) return Rejected;

	 			// Reject move if destination triangle is occupied.
	 			if (Board.GetTriangle(dest) != 0) return Rejected;

	 			// Move is legal, mutate board.
	 			
	 			Board = Board.WithTile(Move.Tile, Board.GetTile(Move.Tile).WithTriangle(Move.Triangle, 0));
	 			Board = Board.WithTile(dest.Tile, Board.GetTile(dest.Tile).WithTriangle(dest.Triangle, 1));

	 			checkForEmpty.Add(Move.Tile);

	 			for (var x = 0; x < 3; ++x)
	 			{
	 				var neighbor = FindSurroundNeighbor(dest, x);
	 				if (neighbor.Tile != FF && !Board.GetTile(neighbor.Tile).IsOutOfPlay())
	 					checkForSurrounded.Add(neighbor);
	 			}
	 		}
	}

	while (checkForSurrounded.Count > 0 || checkForEmpty.Count > 0)
	{
		while (checkForSurrounded.Count > 0)
		{
			var piece = checkForSurrounded[0];
			checkForSurrounded.RemoveAt(0);

			var sum = 0;
			for (var x = 0; x < 3; ++x)
			{
				var neighbor = FindSurroundNeighbor(piece, x);
				if (neighbor.Tile = 0xFF || Board.GetTile(neighbor.Tile).IsOutOfPlay())
					sum += 1;
				else
					sum += Board.GetTriangle(neighbor);
			}

			if (sum == 3)
			{
				Board = Board.WithTile(piece.Tile, Board.GetTile(piece.Tile).WithTriangle(piece.Triangle, 0));
				checkForEmpty.Add(piece.Tile);
			}
		}


		while (checkForEmpty.Count > 0)
		{
			var tileID = checkForEmpty[0];
			checkForEmpty.RemoveAt(0);

			if (!Board.GetTile(tileID).IsEmpty())
				continue;

			// Tile is empty - if it has 3 or less adjacent tiles in a row, it can be removed.


			struct AdjacentRun
			{
				Start;
				End;
				Count;
			}

			var runs = new AdjacentRun[3];
			var runsCount = 0;

			for (var x = 0; x < 6; ++x)
			{
				var neighbor = TileAdjacency[TileID][x];
				if (neighbor != FF && !Board.Tiles[neighbor].IsEmpty())
				{
					if (runsCount == 0)
					{
						runs[0] = new AdjacentRun(x, x, 1);
						runsCount += 1;
					}
					else if (runs[runsCount - 1].End == x - 1)
						runs[runsCount - 1] = new AdjacentRun(runs[runsCount - 1].Start, x, runs[runsCount - 1].Count + 1);
					else
					{
						runs[runsCount] = new AdjacentRun(x,x,1);
						runsCount += 1;
					}
				}
			}

			if (runsCount > 1 && runs[0].Start == 0 && runs[runsCount - 1].End == 5)
			{
				runs[0] = new AdjacenctRun(runs[runCount - 1].Start, runs[0].Start, runs[0].Count + runs[runCount - 1].Count);
				runsCount -= 1;
			}

			if (runsCount == 1 && runs[0].Count <= 3) 
				Board = Board.WithTile(TileID, Board.GetTile(TileId).WithStatusHeldBy(Board.WhoseTurn));

			// Mark adjacent triangles for surround consideration.
			for (var x = 0; x < 6; ++x)
			{
				// Don't check own pieces for surround
				if (x % 2 == Board.WhoseTurn) continue;

				// Don't check tiles that don't exist.
				var neighbor = TileAdjacency[TileID][x];
				if (neighbor == 0xFF || Board.GetTile(neighbor).IsOutOfPlay()) continue;

				checkForSurrounded.Add(new TriangleCoordinate(neighbor, ExposedAdjacency[x]));
			}

			// Check neighboring tiles to see if they can be removed.
			for (var x = 0; x < 6; ++x)
			{
				var neighbor = TileAdjacency[TileID][x];
				if (neighbor == 0xFF || Board.GetTile(neighbor).IsOutOfPlay()) continue;
				checkForEmpty.Add(neighbor);
			}
		}
	}




AI Game State Graph

Cycles are very possible.

class StateTransition
{
	public Move Move;
	public Board Board;
}

var GameStateTable = new Dictionary<Board, List<StateTransition>>();

List<StateTransition> QueryForMoves(Board Board)
{
	List<StateTransition> result;
	if (GameStateTable.TryGetValue(Board, out result))
		return result;
	else
	{
		result = new List<StateTransition>(EnumerateLegalMoves(Board).Select(m => new StateTransition(m, ApplyMove(Board, m))));
		GameStateTable.Add(Board, result);
		return result;
	}
}


IEnumerable<Move> EnumerateLegalMoves(Board)
{
	var canSnipe = Board.Tiles.Count(t => t.IsHeldBy(Board.WhoseTurnNext)) >= 2;

	for (var t = 0; t < 19; ++t)
	{
		var tile = Board.GetTile(t);
		if (tile.IsOutOfPlay())
			continue;
		for (var x = 0; x < 6; ++x)
		{
			if (x % 2 == Board.WhoseTurnNext)
			{
				if (tile.GetTriangle(x) == 1)
					foreach (var move in EnumerateLegalPieceMoves(new TriangleCoordinate(t, x), Board))
						yield return move;
			}
			else
			{
				if (tile.GetTriangle(x) == 1 && canSnipe)
					yield return new Move(t, x, 0, MoveType.Snipe);
			}
		}
	}
}

IEnumerable<Move> EnumerateLegalPieceMoves(TriangleCoordinate Piece, Board Board)
{
	for (var x = 0; x < 6; ++x)
	{
		var neighbor = FindMoveNeighbor(Piece, x);
		if (neighbor.Tile == FF || Board.GetTile(neighbor.Tile).IsOutOfPlay())
			continue;
		if (Board.GetTriangle(neighbor) == 0)
			yield return new Move(Piece, x, MoveType.Move);
	}
}


Plan for building this thing:
	Copy geometery generation, mouse picking, rendering bits from Card Crawl
	Render tiles
	Code up board representation
	Render board
	Mouse picking on board, input moves
	Implement game rules
	Save and Load remembered game states for AI
	AI opponent